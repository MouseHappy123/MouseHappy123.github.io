<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Elasticsearch | Gridea</title>
<link rel="shortcut icon" href="https://MouseHappy123.github.io/favicon.ico?v=1685983394252">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://MouseHappy123.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Elasticsearch | Gridea - Atom Feed" href="https://MouseHappy123.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="前言

只有光头才能变强。


文本已收录至我的GitHub精选文章，欢迎Star：github.com/ZhongFuChen…

不知道大家的公司用Elasticsearch多不多，反正我公司的是有在用的。平时听同事们聊天肯定避免不了不..." />
    <meta name="keywords" content="learn" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://MouseHappy123.github.io">
  <img class="avatar" src="https://MouseHappy123.github.io/images/avatar.png?v=1685983394252" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Elasticsearch
            </h2>
            <div class="post-info">
              <span>
                2023-05-22
              </span>
              <span>
                16 min read
              </span>
              
                <a href="https://MouseHappy123.github.io/tag/learn/" class="post-tag">
                  # learn
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h2 id="前言">前言</h2>
<blockquote>
<p>只有光头才能变强。</p>
</blockquote>
<blockquote>
<p><strong>文本已收录至我的GitHub精选文章，欢迎Star</strong>：<a href="https://github.com/ZhongFuCheng3y/3y" title="https://github.com/ZhongFuCheng3y/3y">github.com/ZhongFuChen…</a></p>
</blockquote>
<p>不知道大家的公司用Elasticsearch多不多，反正我公司的是有在用的。平时听同事们聊天肯定避免不了不认识的技术栈，例如说：把数据放在引擎，从引擎取出数据等等。</p>
<p>如果对引擎不了解的同学，就压根听不懂他们在说什么（我就是听不懂的一位，扎心了）。引擎一般指的是搜索引擎，现在用得比较多的就是Elasticsearch。</p>
<p>这篇文章主要是对Elasticsearch一个简单的入门，没有高深的知识和使用。至少我想做到的是：以后同事们聊引擎了，至少知道他们在讲什么。</p>
<figure data-type="image" tabindex="1"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47fa40e86c62~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<h2 id="什么是elasticsearch">什么是Elasticsearch？</h2>
<blockquote>
<p><a href="https://www.elastic.co/products/Elasticsearch" title="https://www.elastic.co/products/Elasticsearch">Elasticsearch</a> is a real-time, distributed storage, search, and analytics engine</p>
</blockquote>
<p>Elasticsearch 是一个<strong>实时</strong>的<strong>分布式存储、搜索、分析</strong>的引擎。</p>
<p>介绍那儿有几个关键字：</p>
<ul>
<li>实时</li>
<li>分布式</li>
<li>搜索</li>
<li>分析</li>
</ul>
<p>于是我们就得知道Elasticsearch是怎么做到实时的，Elasticsearch的架构是怎么样的（分布式）。存储、搜索和分析（得知道Elasticsearch是怎么存储、搜索和分析的）</p>
<blockquote>
<p>这些问题在这篇文章中都会有提及。</p>
<p>我已经写了200多篇原创技术文章了，后续会写<strong>大数据</strong>相关的文章，如果想看我其他文章的同学，不妨关注我吧。<strong>公众号：Java3y</strong></p>
<p>如果觉得我这篇文章还不错，对你有帮助，<strong>不要吝啬自己的赞</strong>！</p>
</blockquote>
<h2 id="为什么要用elasticsearch">为什么要用Elasticsearch</h2>
<p>在学习一项技术之前，必须先要了解为什么要使用这项技术。所以，为什么要使用Elasticsearch呢？我们在日常开发中，<strong>数据库</strong>也能做到（实时、存储、搜索、分析）。</p>
<p>相对于数据库，Elasticsearch的强大之处就是可以<strong>模糊查询</strong>。</p>
<p>有的同学可能就会说：我数据库怎么就不能模糊查询了？？我反手就给你写一个SQL：</p>
<pre><code class="language-sql">select * from user where name like '%公众号Java3y%'
</code></pre>
<p>这不就可以把<strong>公众号Java3y</strong>相关的内容搜索出来了吗？</p>
<p>的确，这样做的确可以。但是要明白的是：<code>name like %Java3y%</code>这类的查询是不走<strong>索引</strong>的，不走索引意味着：只要你的数据库的量很大（1亿条），你的查询肯定会是<strong>秒</strong>级别的</p>
<blockquote>
<p>如果对数据库索引还不是很了解的同学，建议复看一下我以前的文章。我觉得我当时写得还不赖（哈哈哈）</p>
<p><a href="https://github.com/ZhongFuCheng3y/3y" title="https://github.com/ZhongFuCheng3y/3y">GitHub</a>搜关键字：”索引“</p>
</blockquote>
<p>而且，即便给你从数据库根据<strong>模糊匹配</strong>查出相应的记录了，那往往会返回<strong>大量的数据</strong>给你，往往你需要的数据量并没有这么多，可能50条记录就足够了。</p>
<p>还有一个就是：用户输入的内容往往并没有这么的<strong>精确</strong>，比如我从Google输入<code>ElastcSeach</code>（打错字），但是Google还是能估算我想输入的是<code>Elasticsearch</code></p>
<figure data-type="image" tabindex="2"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47fa423b9824~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<p>而Elasticsearch是专门做<strong>搜索</strong>的，就是为了解决上面所讲的问题而生的，换句话说：</p>
<ul>
<li>Elasticsearch对模糊搜索非常擅长（搜索速度很快）</li>
<li>从Elasticsearch搜索到的数据可以根据<strong>评分</strong>过滤掉大部分的，只要返回评分高的给用户就好了（原生就支持排序）</li>
<li>没有那么准确的关键字也能搜出相关的结果（能匹配有相关性的记录）</li>
</ul>
<p>下面我们就来学学为什么Elasticsearch可以做到上面的几点。</p>
<h2 id="elasticsearch的数据结构">Elasticsearch的数据结构</h2>
<p>众所周知，你要在查询的时候花得更少的时间，你就需要知道他的底层数据结构是怎么样的；举个例子：</p>
<ul>
<li>树型的查找时间复杂度一般是O(logn)</li>
<li>链表的查找时间复杂度一般是O(n)</li>
<li>哈希表的查找时间复杂度一般是O(1)</li>
<li>....不同的数据结构所花的时间往往不一样，你想要查找的时候要<strong>快</strong>，就需要有底层的数据结构支持</li>
</ul>
<p>从上面说Elasticsearch的模糊查询速度很快，那Elasticsearch的底层数据结构是什么呢？我们来看看。</p>
<p>我们根据“<strong>完整的条件</strong>”查找一条记录叫做<strong>正向索引</strong>；我们一本书的章节目录就是正向索引，通过章节名称就找到对应的页码。</p>
<figure data-type="image" tabindex="3"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47fa444c030c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<p>首先我们得知道为什么Elasticsearch为什么可以实现快速的“<strong>模糊匹配</strong>”/“<strong>相关性查询</strong>”，实际上是你写入数据到Elasticsearch的时候会进行<strong>分词</strong>。</p>
<p>还是以上图为例，上图出现了4次“<strong>算法</strong>”这个词，我们能不能根据这次词为它找他对应的目录？Elasticsearch正是这样干的，如果我们根据上图来做这个事，会得到类似这样的结果：</p>
<ul>
<li>算法 <code>-&gt;</code>2,13,42,56</li>
</ul>
<p>这代表着“算法”这个词肯定是在第二页、第十三页、第四十二页、第五十六页出现过。这种根据<strong>某个词</strong>(不完整的条件)再查找对应记录，叫做<strong>倒排索引</strong>。</p>
<p>再看下面的图，好好体会一下：</p>
<figure data-type="image" tabindex="4"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47fa4654b054~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<p>众所周知，世界上有这么多的语言，那Elasticsearch怎么<strong>切分这些词呢？</strong>，Elasticsearch<strong>内置</strong>了一些分词器</p>
<ul>
<li>Standard Analyzer 。按词切分，将词小写</li>
<li>Simple Analyzer。按非字母过滤（符号被过滤掉），将词小写</li>
<li>WhitespaceAnalyzer。按照空格切分，不转小写</li>
<li>....等等等</li>
</ul>
<p>Elasticsearch分词器主要由三部分组成：</p>
<ul>
<li>􏱀􏰉􏰂􏰈􏰂􏰆􏰄Character Filters（文本过滤器，去除HTML）</li>
<li>Tokenizer（按照规则切分，比如空格）</li>
<li>TokenFilter（将切分后的词进行处理，比如转成小写）</li>
</ul>
<p>显然，Elasticsearch是老外写的，内置的分词器都是英文类的，而我们用户搜索的时候往往搜的是中文，现在中文分词器用得最多的就是<strong>IK</strong>。</p>
<p>扯了一大堆，那Elasticsearch的数据结构是怎么样的呢？看下面的图：</p>
<figure data-type="image" tabindex="5"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47fa475f3bf8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<p>我们输入一段文字，Elasticsearch会根据分词器对我们的那段文字进行<strong>分词</strong>（也就是图上所看到的Ada/Allen/Sara..)，这些分词汇总起来我们叫做<code>Term Dictionary</code>，而我们需要通过分词找到对应的记录，这些文档ID保存在<code>PostingList</code></p>
<p>在<code>Term Dictionary</code>中的词由于是非常非常多的，所以我们会为其进行<strong>排序</strong>，等要查找的时候就可以通过<strong>二分</strong>来查，不需要遍历整个<code>Term Dictionary</code></p>
<p>由于<code>Term Dictionary</code>的词实在太多了，不可能把<code>Term Dictionary</code>所有的词都放在内存中，于是Elasticsearch还抽了一层叫做<code>Term Index</code>，这层只存储 部分 <strong>词的前缀</strong>，<code>Term Index</code>会存在内存中（检索会特别快）</p>
<p><code>Term Index</code>在内存中是以<strong>FST</strong>（Finite State Transducers）的形式保存的，其特点是<strong>非常节省内存</strong>。FST有两个优点：</p>
<ul>
<li>1）空间占用小。通过对词典中单词前缀和后缀的重复利用，压缩了存储空间；</li>
<li>2）查询速度快。O(len(str))的查询时间复杂度。</li>
</ul>
<p>前面讲到了<code>Term Index</code>是存储在内存中的，且Elasticsearch用<strong>FST</strong>（Finite State Transducers）的形式保存（节省内存空间）。<code>Term Dictionary</code>在Elasticsearch也是为他进行排序（查找的时候方便），其实<code>PostingList</code>也有对应的优化。</p>
<p><code>PostingList</code>会使用Frame Of Reference（<strong>FOR</strong>）编码技术对里边的数据进行压缩，<strong>节约磁盘空间</strong>。</p>
<figure data-type="image" tabindex="6"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47fa49da7431~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<p><code>PostingList</code>里边存的是文档ID，我们查的时候往往需要对这些文档ID做<strong>交集和并集</strong>的操作（比如在多条件查询时)，<code>PostingList</code>使用<strong>Roaring Bitmaps</strong>来对文档ID进行交并集操作。</p>
<p>使用<strong>Roaring Bitmaps</strong>的好处就是可以节省空间和快速得出交并集的结果。</p>
<figure data-type="image" tabindex="7"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47fa6f348e64~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<p>所以到这里我们总结一下Elasticsearch的数据结构有什么特点：</p>
<figure data-type="image" tabindex="8"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/20/16fc3105213df09c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<h2 id="elasticsearch的术语和架构">Elasticsearch的术语和架构</h2>
<p>从官网的介绍我们已经知道Elasticsearch是<strong>分布式</strong>存储的，如果看过我的文章的同学，对<strong>分布式</strong>这个概念应该不陌生了。</p>
<blockquote>
<p>如果对分布式还不是很了解的同学，建议复看一下我以前的文章。我觉得我当时写得还不赖（哈哈哈）</p>
<p><a href="https://github.com/ZhongFuCheng3y/3y" title="https://github.com/ZhongFuCheng3y/3y">GitHub</a>搜关键字：”SpringCloud“,&quot;Zookeeper&quot;,&quot;Kafka&quot;,&quot;单点登录&quot;</p>
</blockquote>
<p>在讲解Elasticsearch的架构之前，首先我们得了解一下Elasticsearch的一些常见术语。</p>
<ul>
<li><strong>Index</strong>：Elasticsearch的Index相当于数据库的Table</li>
<li><strong>Type</strong>：这个在新的Elasticsearch版本已经废除（在以前的Elasticsearch版本，一个Index下支持多个Type--有点类似于消息队列一个topic下多个group的概念）</li>
<li><strong>Document</strong>：Document相当于数据库的一行记录</li>
<li><strong>Field</strong>：相当于数据库的Column的概念</li>
<li><strong>Mapping</strong>：相当于数据库的Schema的概念</li>
<li><strong>DSL</strong>：相当于数据库的SQL（给我们读取Elasticsearch数据的API）</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47fa741e2cb0~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<p>相信大家看完上面的对比图，对Elasticsearch的一些术语就不难理解了。那Elasticsearch的架构是怎么样的呢？下面我们来看看：</p>
<p>一个Elasticsearch集群会有多个Elasticsearch节点，所谓节点实际上就是运行着Elasticsearch进程的机器。</p>
<figure data-type="image" tabindex="10"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47fa754b4d46~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<p>在众多的节点中，其中会有一个<code>Master Node</code>，它主要负责维护索引元数据、负责切换主分片和副本分片身份等工作（后面会讲到分片的概念），如果主节点挂了，会选举出一个新的主节点。</p>
<figure data-type="image" tabindex="11"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47fa7734d5c0~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<p>从上面我们也已经得知，Elasticsearch最外层的是Index（相当于数据库 表的概念）；一个Index的数据我们可以分发到不同的Node上进行存储，这个操作就叫做<strong>分片</strong>。</p>
<p>比如现在我集群里边有4个节点，我现在有一个Index，想将这个Index在4个节点上存储，那我们可以设置为4个分片。这4个分片的数据<strong>合起来</strong>就是Index的数据</p>
<figure data-type="image" tabindex="12"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47fa7d0995a6~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<p>为什么要分片？原因也很简单：</p>
<ul>
<li>如果一个Index的数据量太大，只有一个分片，那只会在一个节点上存储，随着数据量的增长，一个节点未必能把一个Index存储下来。</li>
<li>多个分片，在写入或查询的时候就可以并行操作（从各个节点中读写数据，提高吞吐量）</li>
</ul>
<p>现在问题来了，如果某个节点挂了，那部分数据就丢了吗？显然Elasticsearch也会想到这个问题，所以分片会有主分片和副本分片之分（为了实现<strong>高可用</strong>）</p>
<p>数据写入的时候是<strong>写到主分片</strong>，副本分片会<strong>复制</strong>主分片的数据，读取的时候<strong>主分片和副本分片都可以读</strong>。</p>
<blockquote>
<p>Index需要分为多少个分片和副本分片都是可以通过配置设置的</p>
</blockquote>
<figure data-type="image" tabindex="13"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47fa92be5184~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<p>如果某个节点挂了，前面所提高的<code>Master Node</code>就会把对应的副本分片提拔为主分片，这样即便节点挂了，数据就不会丢。</p>
<p>到这里我们可以简单总结一下Elasticsearch的架构了：</p>
<figure data-type="image" tabindex="14"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47faa349b120~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<h2 id="elasticsearch-写入的流程">Elasticsearch 写入的流程</h2>
<p>上面我们已经知道当我们向Elasticsearch写入数据的时候，是写到主分片上的，我们可以了解更多的细节。</p>
<p>客户端写入一条数据，到Elasticsearch集群里边就是由<strong>节点</strong>来处理这次请求：</p>
<figure data-type="image" tabindex="15"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47faa6883442~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<p>集群上的每个节点都是<code>coordinating node</code>（<strong>协调节点</strong>），协调节点表明这个节点可以做<strong>路由</strong>。比如<strong>节点1</strong>接收到了请求，但发现这个请求的数据应该是由<strong>节点2</strong>处理（因为主分片在<strong>节点2</strong>上），所以会把请求转发到<strong>节点2</strong>上。</p>
<ul>
<li>coodinate（<strong>协调</strong>）节点通过hash算法可以计算出是在哪个主分片上，然后<strong>路由到对应的节点</strong></li>
<li><code>shard = hash(document_id) % (num_of_primary_shards)</code></li>
</ul>
<p>路由到对应的节点以及对应的主分片时，会做以下的事：</p>
<ol>
<li>将数据写到内存缓存区</li>
<li>然后将数据写到translog缓存区</li>
<li>每隔<strong>1s</strong>数据从buffer中refresh到FileSystemCache中，生成segment文件，一旦生成segment文件，就能通过索引查询到了</li>
<li>refresh完，memory buffer就清空了。</li>
<li>每隔<strong>5s</strong>中，translog 从buffer flush到磁盘中</li>
<li>定期/定量从FileSystemCache中,结合translog内容<code>flush index</code>到磁盘中。</li>
</ol>
<figure data-type="image" tabindex="16"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47faa68cd009~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<p>解释一下：</p>
<ul>
<li>Elasticsearch会把数据先写入内存缓冲区，然后每隔<strong>1s</strong>刷新到文件系统缓存区（当数据被刷新到文件系统缓冲区以后，数据才可以被检索到）。所以：Elasticsearch写入的数据需要<strong>1s</strong>才能查询到</li>
<li>为了防止节点宕机，内存中的数据丢失，Elasticsearch会另写一份数据到<strong>日志文件</strong>上，但最开始的还是写到内存缓冲区，每隔<strong>5s</strong>才会将缓冲区的刷到磁盘中。所以：Elasticsearch某个节点如果挂了，可能会造成有<strong>5s</strong>的数据丢失。</li>
<li>等到磁盘上的translog文件大到一定程度或者超过了30分钟，会触发<strong>commit</strong>操作，将内存中的segement文件异步刷到磁盘中，完成持久化操作。</li>
</ul>
<p>说白了就是：写内存缓冲区（<strong>定时</strong>去生成segement，生成translog），能够<strong>让数据能被索引、被持久化</strong>。最后通过commit完成一次的持久化。</p>
<figure data-type="image" tabindex="17"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47faabc5faee~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<p>等主分片写完了以后，会将数据并行发送到副本集节点上，等到所有的节点写入成功就返回<strong>ack</strong>给协调节点，协调节点返回<strong>ack</strong>给客户端，完成一次的写入。</p>
<h2 id="elasticsearch更新和删除">Elasticsearch更新和删除</h2>
<p>Elasticsearch的更新和删除操作流程：</p>
<ul>
<li>给对应的<code>doc</code>记录打上<code>.del</code>标识，如果是删除操作就打上<code>delete</code>状态，如果是更新操作就把原来的<code>doc</code>标志为<code>delete</code>，然后重新新写入一条数据</li>
</ul>
<p>前面提到了，每隔<strong>1s</strong>会生成一个segement 文件，那segement文件会越来越多越来越多。Elasticsearch会有一个<strong>merge</strong>任务，会将多个segement文件<strong>合并</strong>成一个segement文件。</p>
<p>在合并的过程中，会把带有<code>delete</code>状态的<code>doc</code>给<strong>物理删除</strong>掉。</p>
<figure data-type="image" tabindex="18"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47faaa8cd3d0~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<h2 id="elasticsearch查询">Elasticsearch查询</h2>
<p>查询我们最简单的方式可以分为两种：</p>
<ul>
<li>根据ID查询doc</li>
<li>根据query（搜索词）去查询匹配的doc</li>
</ul>
<pre><code class="language-auto">public TopDocs search(Query query, int n);
public Document doc(int docID);
</code></pre>
<p>根据<strong>ID</strong>去查询具体的doc的流程是：</p>
<ul>
<li>检索内存的Translog文件</li>
<li>检索硬盘的Translog文件</li>
<li>检索硬盘的Segement文件</li>
</ul>
<p>根据<strong>query</strong>去匹配doc的流程是：</p>
<ul>
<li>同时去查询内存和硬盘的Segement文件</li>
</ul>
<figure data-type="image" tabindex="19"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47fac5f982e1~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<p>从上面所讲的写入流程，我们就可以知道：Get（通过ID去查Doc是实时的），Query（通过query去匹配Doc是近实时的）</p>
<ul>
<li>因为segement文件是每隔一秒才生成一次的</li>
</ul>
<p>Elasticsearch查询又分可以为三个阶段：</p>
<ul>
<li>
<p>QUERY_AND_FETCH（查询完就返回整个Doc内容）</p>
</li>
<li>
<p>QUERY_THEN_FETCH（先查询出对应的Doc id ，然后再根据Doc id 匹配去对应的文档）</p>
</li>
<li>
<p>DFS_QUERY_THEN_FETCH（先算分，再查询）</p>
<ul>
<li>「这里的分指的是 <strong>词频率和文档的频率</strong>（Term Frequency、Document Frequency）众所周知，出现频率越高，相关性就更强」</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="20"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47fad7a088a5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<p>一般我们用得最多的就是<strong>QUERY_THEN_FETCH</strong>，第一种查询完就返回整个Doc内容（QUERY_AND_FETCH）只适合于只需要查一个分片的请求。</p>
<p><strong>QUERY_THEN_FETCH</strong>总体的流程流程大概是：</p>
<ul>
<li>客户端请求发送到集群的某个节点上。集群上的每个节点都是coordinate node（协调节点）</li>
<li>然后协调节点将搜索的请求转发到<strong>所有分片上</strong>（主分片和副本分片都行）</li>
<li>每个分片将自己搜索出的结果<code>(doc id)</code>返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</li>
<li>接着由协调节点根据 <code>doc id</code> 去各个节点上<strong>拉取实际</strong>的 <code>document</code> 数据，最终返回给客户端。</li>
</ul>
<p><strong>Query Phase阶段</strong>时节点做的事：</p>
<ul>
<li>协调节点向目标分片发送查询的命令（转发请求到主分片或者副本分片上）</li>
<li>数据节点（在每个分片内做过滤、排序等等操作），返回<code>doc id</code>给协调节点</li>
</ul>
<p><strong>Fetch Phase阶段</strong>时节点做的是：</p>
<ul>
<li>协调节点得到数据节点返回的<code>doc id</code>，对这些<code>doc id</code>做聚合，然后将目标数据分片发送抓取命令（希望拿到整个Doc记录）</li>
<li>数据节点按协调节点发送的<code>doc id</code>，拉取实际需要的数据返回给协调节点</li>
</ul>
<p>主流程我相信大家也不会太难理解，说白了就是：<strong>由于Elasticsearch是分布式的，所以需要从各个节点都拉取对应的数据，然后最终统一合成给客户端</strong></p>
<p>只是Elasticsearch把这些活都干了，我们在使用的时候无感知而已。</p>
<figure data-type="image" tabindex="21"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/14/16fa47fad7612ede~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<h2 id="最后">最后</h2>
<p>这篇文章主要对Elasticsearch简单入了个门，实际使用肯定还会遇到很多坑，但我目前就到这里就结束了。</p>
<figure data-type="image" tabindex="22"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/20/16fc310531f3859f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<p>如果文章写得有错误的地方，欢迎<strong>友善</strong>指正交流。等年后还会继续更新大数据相关的入门文章，有兴趣的欢迎关注我的公众号。<strong>觉得这篇文章还行，可以给我一个赞👍</strong></p>
<p>参考资料：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247486253&amp;idx=3&amp;sn=e703437100bec5bd377220b8c1c02ecd&amp;chksm=ebd74a2cdca0c33a49519e11397db07a636d82fb6ad183746edc5f13ec714b44d6b678616bfd&amp;token=711412693&amp;lang=zh_CN#rd" title="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247486253&amp;idx=3&amp;sn=e703437100bec5bd377220b8c1c02ecd&amp;chksm=ebd74a2cdca0c33a49519e11397db07a636d82fb6ad183746edc5f13ec714b44d6b678616bfd&amp;token=711412693&amp;lang=zh_CN#rd">聊聊 Elasticsearch 的倒排索引</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247486147&amp;idx=2&amp;sn=a47d2796ffaef44de54ca4adb91652a7&amp;chksm=ebd74bc2dca0c2d40b25f005710804bdda8b36d405efd70200e0489aa782283d84be46d8e1bc&amp;token=711412693&amp;lang=zh_CN#rd" title="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247486147&amp;idx=2&amp;sn=a47d2796ffaef44de54ca4adb91652a7&amp;chksm=ebd74bc2dca0c2d40b25f005710804bdda8b36d405efd70200e0489aa782283d84be46d8e1bc&amp;token=711412693&amp;lang=zh_CN#rd">为什么需要 Elasticsearch</a></li>
<li><a href="https://www.cnblogs.com/bonelee/p/6226185.html" title="https://www.cnblogs.com/bonelee/p/6226185.html">lucene字典实现原理——FST</a></li>
<li><a href="https://www.cnblogs.com/jajian/p/10465519.html" title="https://www.cnblogs.com/jajian/p/10465519.html">Elasticsearch性能优化</a></li>
<li><a href="https://www.cnblogs.com/stoneFang/p/11254521.html" title="https://www.cnblogs.com/stoneFang/p/11254521.html">深入分析Elastic Search的写入过程</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34674517" title="https://zhuanlan.zhihu.com/p/34674517">Elasticsearch内核解析 - 查询篇</a></li>
</ul>
<p>如果大家想要<strong>实时</strong>关注我更新的文章以及分享的干货的话，可以关注我的公众号「<strong>Java3y</strong>」。</p>
<ul>
<li>🔥<strong>海量视频资源</strong></li>
<li>🔥<strong>Java精美脑图</strong></li>
<li>🔥<strong>Java学习路线</strong></li>
<li>🔥<strong>开发常用工具</strong></li>
<li>🔥<strong>精美整理好的PDF电子书</strong></li>
</ul>
<p>在公众号下回复「<strong>888</strong>」即可获取！！</p>
<figure data-type="image" tabindex="23"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/20/16fc310538aa04b5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" alt="" loading="lazy"></figure>
<blockquote>
<p><strong>本已收录至我的GitHub精选文章，欢迎Star</strong>：<a href="https://github.com/ZhongFuCheng3y/3y" title="https://github.com/ZhongFuCheng3y/3y">github.com/ZhongFuChen…</a></p>
<p><strong>求点赞</strong> <strong>求关注️</strong> <strong>求分享👥</strong> <strong>求留言💬</strong> 对我来说真的 <strong>非常有用</strong>！！！</p>
</blockquote>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFelasticsearch">什么是Elasticsearch？</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8elasticsearch">为什么要用Elasticsearch</a></li>
<li><a href="#elasticsearch%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">Elasticsearch的数据结构</a></li>
<li><a href="#elasticsearch%E7%9A%84%E6%9C%AF%E8%AF%AD%E5%92%8C%E6%9E%B6%E6%9E%84">Elasticsearch的术语和架构</a></li>
<li><a href="#elasticsearch-%E5%86%99%E5%85%A5%E7%9A%84%E6%B5%81%E7%A8%8B">Elasticsearch 写入的流程</a></li>
<li><a href="#elasticsearch%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4">Elasticsearch更新和删除</a></li>
<li><a href="#elasticsearch%E6%9F%A5%E8%AF%A2">Elasticsearch查询</a></li>
<li><a href="#%E6%9C%80%E5%90%8E">最后</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://MouseHappy123.github.io/post/dui-mysql-de-yi-xie-si-kao/">
              <h3 class="post-title">
                对mysql的一些思考
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://MouseHappy123.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
